<!DOCTYPE html>
<html lang="en-US">
    <head>
        <meta charset="utf-8"> 
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="author" content="Alec Nikolas Reiter" />
        <meta name="copyright" content="Alec Nikolas Reiter" />

        <script src="//ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
        <link rel="stylesheet" href="/theme/slicknav.css">
        <script src="/theme/jquery.slicknav.min.js"></script>
        <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">
        <script type="text/javascript"
            src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
        </script>
        <!--[if lt IE 9]>
        <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.2/html5shiv.js"></script>
        <![endif]-->


<meta name="keywords" content="python3, metaprogramming, tutorials, " />
        <title>Currying and Memoizing Metaclasses - from alec.thoughts import *
</title>
        <link href="http://cdn-images.mailchimp.com/embedcode/slim-081711.css" rel="stylesheet" type="text/css">
        <link href="//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.1/css/bootstrap-combined.min.css" rel="stylesheet">
        <link rel="stylesheet" type="text/css" href="http://justanr.github.io/theme/css/style.css" media="screen">
        <link rel="stylesheet" type="text/css" href="http://justanr.github.io/theme/css/solarizedlight.css" media="screen">
        <link rel="shortcut icon" href="http://justanr.github.io/theme/images/favicon.ico" type="image/x-icon" />
        <link rel="apple-touch-icon" href="http://justanr.github.io/theme/images/apple-touch-icon.png" />
        <link rel="apple-touch-icon" sizes="57x57" href="http://justanr.github.io/theme/images/apple-touch-icon-57x57.png" />
        <link rel="apple-touch-icon" sizes="72x72" href="http://justanr.github.io/theme/images/apple-touch-icon-72x72.png" />
        <link rel="apple-touch-icon" sizes="114x114" href="http://justanr.github.io/theme/images/apple-touch-icon-114x114.png" />
        <link rel="apple-touch-icon" sizes="144x144" href="http://justanr.github.io/theme/images/apple-touch-icon-144x144.png" />
        <link rel="icon" href="http://justanr.github.io/theme/images/apple-touch-icon-144x144.png" />
    <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-64904436-1']);
    _gaq.push(['_trackPageview']);
    (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
    </script>
    </head>
    <body>
        <div id="content-sans-footer">
        <div class="navbar navbar-static-top">
            <div class="navbar-inner">
                <div class="container">
                    <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </a>
                    <a class="brand" href="http://justanr.github.io/"><span class=site-name>from alec.thoughts import *</span></a>
                    <div class="nav-collapse collapse">
                        <ul class="nav pull-right top-menu">
                            <li ><a href="http://justanr.github.io">Home</a></li>
                            <li ><a href="http://justanr.github.io/categories.html">Categories</a></li>
                            <li ><a href="http://justanr.github.io/tags.html">Tags</a></li>
                            <li ><a href="http://justanr.github.io/archives.html">Archives</a></li>
                            <li><form class="navbar-search" action="http://justanr.github.io/search.html" onsubmit="return validateForm(this.elements['q'].value);"> <input type="text" class="search-query" placeholder="Search" name="q" id="tipue_search_input"></form></li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
        <div class="container-fluid">
            <div class="row-fluid">
                <div class="span1"></div>
                <div class="span10">
<article>
<div class="row-fluid">
    <header class="page_header span10 offset2">
    <h1><a href="http://justanr.github.io/currying-and-memoizing-metaclasses"> Currying and Memoizing Metaclasses  </a></h1>
    </header>
</div>

<div class="row-fluid">
        <div class="span8 offset2 article-content">

            <p>I've been playing with the <a class="reference external" href="https://github.com/pytoolz/toolz">toolz</a>
library recently and it's pretty great, especially their implementation
of the curry and memoize decorators. However, applying these to classes
creates a problem: inheritance. A quick example before we delve into
solving this problem:</p>
<pre class="code ipython3 literal-block">
<span class="kn">from</span> <span class="nn">toolz</span> <span class="k">import</span> <span class="n">curry</span><span class="p">,</span> <span class="n">memoize</span>

<span class="nd">&#64;curry</span>
<span class="k">class</span> <span class="nc">Person</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">age</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">age</span> <span class="o">=</span> <span class="n">age</span>
    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;Person(name=</span><span class="si">{!r}</span><span class="s2">, age=</span><span class="si">{!r}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">age</span><span class="p">)</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">Person</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">'alec'</span><span class="p">)</span>
<span class="n">p</span><span class="p">(</span><span class="n">age</span><span class="o">=</span><span class="mi">26</span><span class="p">)</span>
</pre>
<pre class="literal-block">
Person(name='alec', age=26)
</pre>
<p>Currying a class we don't expect to inherit from is easy. However, if
someone comes along and says, &quot;I'd like to create a subclass&quot; then
there's an issue...</p>
<pre class="code ipython3 literal-block">
<span class="k">class</span> <span class="nc">PersonWithHobby</span><span class="p">(</span><span class="n">Person</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">age</span><span class="p">,</span> <span class="n">hobby</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">PersonWithHobby</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">age</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hobby</span> <span class="o">=</span> <span class="n">hobby</span>
</pre>
<pre class="literal-block">
---------------------------------------------------------------------------

TypeError                                 Traceback (most recent call last)

&lt;ipython-input-2-12f89c179297&gt; in &lt;module&gt;()
----&gt; 1 class PersonWithHobby(Person):
      2     def __init__(self, name, age, hobby):
      3         super(PersonWithHobby, self).__init__(name, age)
      4         self.hobby = hobby


/home/justanr/contrib/toolz/toolz/functoolz.py in __init__(self, func, *args, **kwargs)
    155     def __init__(self, func, *args, **kwargs):
    156         if not callable(func):
--&gt; 157             raise TypeError(&quot;Input must be callable&quot;)
    158
    159         # curry- or functools.partial-like object?  Unpack and merge arguments


TypeError: Input must be callable
</pre>
<p>Oh...that's a problem. Instead, we have to inherit from <tt class="docutils literal">Person.func</tt>
in the case of this decorator. Just like if we had partialled the class
manually:</p>
<pre class="code ipython3 literal-block">
<span class="k">class</span> <span class="nc">PersonWithHobby</span><span class="p">(</span><span class="n">Person</span><span class="o">.</span><span class="n">func</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">age</span><span class="p">,</span> <span class="n">hobby</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">PersonWithHobby</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">age</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hobby</span> <span class="o">=</span> <span class="n">hobby</span>
</pre>
<p>But if you're anything like me that inheritance line is...bothersome.
Because we're locking up the original class in the curry decorator,
there's no clean way to get it out and just inherit from it other than
accessing the decorator's attributes themselves. I tried for about six
hours and ended up roping some folks at
<a class="reference external" href="http://www.reddit.com/r/learnpython">/r/learnpython</a> into that mess
as well.</p>
<p>Using the memoize decorator presents the same issue. Instead, what we'd
probably like to do is not only inherit from the class, but retain its
currying or memoizing characteristics.</p>
<div class="section" id="metaclasses-are-to-classes-as-decorators-are-to-functions">
<h2>Metaclasses are to classes as decorators are to functions</h2>
<p>Ooooh, the scary &quot;M&quot; word. Tim Peters once said,</p>
<pre class="literal-block">
Metaclasses are deeper magic than 99% of users should ever worry about. If you wonder whether you need them, you don't (the people who actually need them know with certainty that they need them, and don't need an explanation about why).
</pre>
<p>That's a pretty big warning to attach to something. Metaclasses are deep
magic, but it's relatively straight forward magic. If you're unsure
about <em>what</em> a metaclass is, check out <a class="reference external" href="http://eli.thegreenplace.net/2011/08/14/python-metaclasses-by-example">Eli Bendersky's Python
metaclasses by
example</a>
for an overview. But the short of it is this:</p>
<ul class="simple">
<li><em>Everything</em> in Python is an Object (including: functions, classes
and even modules)</li>
<li>Classes make objects.</li>
<li>If classes are objects, too, it serves to reason that there's a class
that makes them</li>
<li>That class-making-class is called type.</li>
</ul>
<p><tt class="docutils literal">type</tt> is our magic that takes a class body and makes it an object.
This is the default <em>metaclass</em> for all of our classes. However, we
don't want vanilla Python classes. We'd like to have classes that are
curryable or can be memoized.</p>
<p>The problem with using a decorator is that it'll happily apply to the
immediate object, but it generally won't apply to an entire inheritance
chain. But a metaclass will.</p>
<div class="section" id="an-aside-new-vs-a-metaclass">
<h3>An Aside: new vs a Metaclass</h3>
<p>Both of what I'm about to show <em>could</em> be achieved by overriding
<tt class="docutils literal">__new__</tt> on a regular class. However, that's no fun. Though, since
metaclasses are more about creating classes than instances, I couldn't
blame you if you created <tt class="docutils literal">CurryableMixin</tt> and <tt class="docutils literal">MemoizedMixin</tt>
classes and called it a day.</p>
<p>However, I find cooperative multiple inheritance that uses <tt class="docutils literal">__new__</tt>
to be difficult to manage, especially because <tt class="docutils literal">object.__new__</tt> accepts
<em>no</em> arguments other than the class it makes the object out of. So some
sort of sink would be needed to strip off any extra <tt class="docutils literal">kwargs</tt> passed
along and then you have to consider if inheriting from an immutable
object comes afterwards and if it'll need any of the kwargs and it'll
quickly turn into a mess if you try to capture all the corner cases.</p>
</div>
</div>
<div class="section" id="curryable-metaclass">
<h2>Curryable Metaclass</h2>
<p>This is actually the simpler of the two metaclasses to write,
surprisingly. Instead of doing any magic in <tt class="docutils literal">__new__</tt> or <tt class="docutils literal">__init__</tt>
we simply override <tt class="docutils literal">__call__</tt> instead. <tt class="docutils literal">__call__</tt> in this case is
analogous to <tt class="docutils literal">__new__</tt> in a regular class, this handles instantiation
of an actual object, rather than class creation.</p>
<pre class="code ipython3 literal-block">
<span class="kn">from</span> <span class="nn">functools</span> <span class="k">import</span> <span class="n">wraps</span>

<span class="k">class</span> <span class="nc">Curryable</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="c1"># one level up from classes</span>
    <span class="c1"># cls here is the actual class we've created already</span>
    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># we'd like to preserve metadata but not migrate</span>
        <span class="c1"># the underlying dictionary</span>
        <span class="nd">&#64;wraps</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">updated</span><span class="o">=</span><span class="p">[])</span>
        <span class="c1"># distinguish from what was passed to __call__</span>
        <span class="c1"># and what as passed to currier</span>
        <span class="k">def</span> <span class="nf">currier</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="o">**</span><span class="n">k</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">Curryable</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span><span class="o">.</span><span class="fm">__call__</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="o">**</span><span class="n">k</span><span class="p">)</span>
        <span class="c1"># there's sometimes odd behavior if this isn't done</span>
        <span class="k">return</span> <span class="n">curry</span><span class="p">(</span><span class="n">currier</span><span class="p">)(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre>
<pre class="code ipython3 literal-block">
<span class="k">class</span> <span class="nc">Person</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">Curryable</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">age</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">age</span> <span class="o">=</span> <span class="n">age</span>
    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;Person(name=</span><span class="si">{!r}</span><span class="s2">, age=</span><span class="si">{!r}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">age</span><span class="p">)</span>
</pre>
<pre class="code ipython3 literal-block">
<span class="n">p</span> <span class="o">=</span> <span class="n">Person</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">'alec'</span><span class="p">)</span>
</pre>
<pre class="code ipython3 literal-block">
<span class="n">p</span><span class="p">(</span><span class="n">age</span><span class="o">=</span><span class="mi">26</span><span class="p">)</span>
</pre>
<pre class="literal-block">
Person(name='alec', age=26)
</pre>
<p><tt class="docutils literal">curry</tt> guards against type errors, allowing us to repeatedly apply
arguments until we get something that doesn't throw a TypeError. This
<em>also</em> allows us to build inheritance chains where we simply pass up
<tt class="docutils literal">kwargs</tt> to the next class:</p>
<pre class="code ipython3 literal-block">
<span class="k">class</span> <span class="nc">PersonWithHobby</span><span class="p">(</span><span class="n">Person</span><span class="p">):</span>
    <span class="c1"># as an example only; it's still best practice to declare required parameters</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hobby</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">PersonWithHobby</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hobby</span> <span class="o">=</span> <span class="n">hobby</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;Person(name=</span><span class="si">{!r}</span><span class="s2">, age=</span><span class="si">{!r}</span><span class="s2">, hobby=</span><span class="si">{!r}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">age</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">hobby</span><span class="p">)</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">PersonWithHobby</span><span class="p">(</span><span class="n">hobby</span><span class="o">=</span><span class="s1">'coding'</span><span class="p">)</span>
</pre>
<pre class="code ipython3 literal-block">
<span class="n">p</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">'alec'</span><span class="p">,</span> <span class="n">age</span><span class="o">=</span><span class="mi">26</span><span class="p">)</span>
</pre>
<pre class="literal-block">
Person(name='alec', age=26, hobby='coding')
</pre>
</div>
<div class="section" id="memoizing-metaclass">
<h2>Memoizing Metaclass</h2>
<p>This one is quite a bit more difficult to write. Instead of just
overriding <tt class="docutils literal">__call__</tt>, we need to override <tt class="docutils literal">__init__</tt> as well <em>and</em>
provide a key-value store. Instead of throwing a bunch of code all at
once, I'd rather disect it bit by bit:</p>
<div class="section" id="default-cache-key">
<h3>default_cache_key</h3>
<p>By default, <tt class="docutils literal">memoize</tt> will attempt to do the right thing. However, it
uses the inspect module to determine if there's keyword arguments. This
can act oddly sometimes and if memoize doesn't detect keyword arguments,
it'll only memoize positional arguments. Instead, we'd like to <em>always</em>
memoize both. We could go further and attempt to bind positional keyword
arguments with their actual names, but for now, this will suffice.</p>
<pre class="code ipython3 literal-block">
<span class="k">def</span> <span class="nf">default_cache_key</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">args</span> <span class="ow">or</span> <span class="kc">None</span><span class="p">,</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">())</span> <span class="ow">or</span> <span class="kc">None</span><span class="p">)</span>
</pre>
</div>
<div class="section" id="hybridvaluestore">
<h3>HybridValueStore</h3>
<p>If you're not familiar with descriptors, I recommend <a class="reference external" href="http://nbviewer.ipython.org/urls/gist.github.com/ChrisBeaumont/5758381/raw/descriptor_writeup.ipynb">Chris Beaumont's
Python Descriptors
Demystified</a>
and <a class="reference external" href="https://www.youtube.com/watch?v=ZdvpNaWwx24">Simeon Franklin's Descriptor
talk</a></p>
<p>We'll also have to centralize our cache so we can control it. However,
this presents a problem. If we have two memoized classes, they shouldn't
be able to poke at each other's caches. So simply setting a dictionary
on the metaclass won't work. Rather we need to allow each class to only
access it's particular cache and actual instances of the class probably
shouldn't have access to the cache directly either since their only
business with it is existing in it.</p>
<p>And overriding a class's cache should also affect the master cache as
well so the two remain consistent. And deleting a class's cache simply
pops it from the master cache.</p>
<p>With that in mind, we can write a descriptor that wraps any key-value
store and either return the whole store if it's the metaclass accessing
it or, if it's a memoized class accessing it, the descriptor will return
just the class's cache. Since we're one level up from classes and
instances, I've commented which parameters correspond to the class and
metaclass.</p>
<pre class="code ipython3 literal-block">
<span class="k">class</span> <span class="nc">HybridValueStore</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">valuestore</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">valuestore</span> <span class="o">=</span> <span class="n">valuestore</span>

            <span class="c1">#   |+------------------&gt; The Descriptor Instance</span>
            <span class="c1">#   |     |+------------&gt; The Memoized Class</span>
            <span class="c1">#   |     |     |+------&gt; The Metaclass</span>
    <span class="k">def</span> <span class="nf">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inst</span><span class="p">,</span> <span class="bp">cls</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">inst</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">valuestore</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">valuestore</span><span class="p">[</span><span class="n">inst</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__set__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inst</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">valuestore</span><span class="p">[</span><span class="n">inst</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">__delete__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inst</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">valuestore</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">inst</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
</pre>
</div>
<div class="section" id="actual-metaclass">
<h3>Actual Metaclass</h3>
<p>Now, with those two out of the way, we can actually put the pieces
together.</p>
<pre class="code ipython3 literal-block">
<span class="kn">from</span> <span class="nn">toolz</span> <span class="k">import</span> <span class="n">memoize</span>

<span class="k">class</span> <span class="nc">Memoized</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="n">cache</span> <span class="o">=</span> <span class="n">HybridValueStore</span><span class="p">({})</span>
    <span class="n">cache_key</span> <span class="o">=</span> <span class="n">HybridValueStore</span><span class="p">({})</span>

    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">mcls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">attrs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">Memoized</span><span class="p">,</span> <span class="n">mcls</span><span class="p">)</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">mcls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">attrs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">attrs</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">default_cache_key</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">cache</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cache</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">cache</span> <span class="o">=</span> <span class="n">cache</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">cache_key</span> <span class="o">=</span> <span class="n">key</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Memoized</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">attrs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nd">&#64;memoize</span><span class="p">(</span><span class="n">cache</span><span class="o">=</span><span class="bp">cls</span><span class="o">.</span><span class="n">cache</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="bp">cls</span><span class="o">.</span><span class="n">cache_key</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">memoizer</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="o">**</span><span class="n">k</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">Memoized</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span><span class="o">.</span><span class="fm">__call__</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="o">**</span><span class="n">k</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">memoizer</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre>
<p>The master cache is implemented with HybridValueStore using a regular
dictionary that we add further mappings. Since we've provided a
<tt class="docutils literal">__set__</tt> method, we can use a normal dictionary rather than something
like <tt class="docutils literal">defaultdict</tt> which provides just-in-time access to keys.</p>
<p>We also use the same thing with the cache_keys as well. Originally, I
had planned on storing the key <em>on</em> the class's cache, but seeing as
<tt class="docutils literal">dict</tt> can't host arbitrary attributes, that plan fell through.
Rather, storing the key alongside the cache as a seperate attribute
seems to function just fine.</p>
<p><tt class="docutils literal">__new__</tt> is where things start to get strange. In addition to the
normal parameters it accepts, there's also <tt class="docutils literal">**kwargs</tt>. This is to
allow passing keyword arguments to the metaclass, which we'll see in a
moment. In <tt class="docutils literal">__init__</tt> is where the extra keywords come into play:</p>
<ul class="simple">
<li><tt class="docutils literal">key</tt> is the function we'll use to create cache keys and defaults
to the function described above,</li>
<li><tt class="docutils literal">cache</tt> is the mapping for storing instances. If it's not provided,
it simply defaults to a regular dictionary. However, this allows
using things like <tt class="docutils literal">weakref.WeakValueDictionary</tt> or another
specialized mapping as the container rather than a regular
dictionary.</li>
</ul>
<p>Both of these are simple stored on the instance of the metaclass (which
is the created class) but, interestingly, these <em>aren't</em> available to
the instances created from the class.</p>
<p>And finally, <tt class="docutils literal">__call__</tt> is where the memoization actually happens. A
wrapper is created to memoize and provided with the class's cache and
cache key function and the actual object instantiation is delegated to
the next metaclass in the MRO (typically <tt class="docutils literal">type</tt>).</p>
</div>
<div class="section" id="in-action">
<h3>In Action</h3>
<p>After all that, let's see this bad boy do its work, just two simple
classes will work.</p>
<pre class="code ipython3 literal-block">
<span class="k">class</span> <span class="nc">Frob</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">Memoized</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">frob</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">frob</span> <span class="o">=</span> <span class="n">frob</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;Frob(</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frob</span><span class="p">)</span>

<span class="c1"># simply here to show HybridValueStore's fine grained access</span>
<span class="k">class</span> <span class="nc">Dummy</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">Memoized</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;Dummy&quot;</span>

<span class="n">f</span> <span class="o">=</span> <span class="n">Frob</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">d</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">()</span>
<span class="k">assert</span> <span class="n">f</span> <span class="ow">is</span> <span class="n">Frob</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="s2">&quot;guess it didn't work&quot;</span>
</pre>
<p>That went well. Let's see some other parts in action:</p>
<pre class="code ipython3 literal-block">
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Master Cache: &quot;</span><span class="p">,</span> <span class="n">Memoized</span><span class="o">.</span><span class="n">cache</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Frob   Cache: &quot;</span><span class="p">,</span> <span class="n">Frob</span><span class="o">.</span><span class="n">cache</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Dummy  Cache: &quot;</span><span class="p">,</span> <span class="n">Dummy</span><span class="o">.</span><span class="n">cache</span><span class="p">)</span>
</pre>
<pre class="literal-block">
Master Cache:  {&lt;class '__main__.Dummy'&gt;: {(None, None): Dummy}, &lt;class '__main__.Frob'&gt;: {((1,), None): Frob(1)}}
Frob   Cache:  {((1,), None): Frob(1)}
Dummy  Cache:  {(None, None): Dummy}
</pre>
<p>Good to see the fine-grained access to the cache attribute is working.
How about if we reset the cache for Frob?</p>
<pre class="code ipython3 literal-block">
<span class="n">Frob</span><span class="o">.</span><span class="n">cache</span> <span class="o">=</span> <span class="p">{}</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Master Cache: &quot;</span><span class="p">,</span> <span class="n">Memoized</span><span class="o">.</span><span class="n">cache</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Frob   Cache: &quot;</span><span class="p">,</span> <span class="n">Frob</span><span class="o">.</span><span class="n">cache</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Dummy  Cache: &quot;</span><span class="p">,</span> <span class="n">Dummy</span><span class="o">.</span><span class="n">cache</span><span class="p">)</span>
</pre>
<pre class="literal-block">
Master Cache:  {&lt;class '__main__.Dummy'&gt;: {(None, None): Dummy}, &lt;class '__main__.Frob'&gt;: {}}
Frob   Cache:  {}
Dummy  Cache:  {(None, None): Dummy}
</pre>
<p>Awesome. Now, there was the curious keyword arguments that we can pass
to the metaclass...but <em>how</em>? It's simple, we pass them the same way
metaclasses are declared (at least in Python 3):</p>
<pre class="code ipython3 literal-block">
<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">OrderedDict</span>

<span class="k">def</span> <span class="nf">make_string_key</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">KeywordTest</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">Memoized</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">make_string_key</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="n">OrderedDict</span><span class="p">()):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">pass</span>

<span class="n">kwt1</span> <span class="o">=</span> <span class="n">KeywordTest</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">kwt2</span> <span class="o">=</span> <span class="n">KeywordTest</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
</pre>
<pre class="code ipython3 literal-block">
<span class="nb">print</span><span class="p">(</span><span class="n">KeywordTest</span><span class="o">.</span><span class="n">cache</span><span class="p">)</span>
</pre>
<pre class="literal-block">
OrderedDict([('(1, 2, 3){}', &lt;__main__.KeywordTest object at 0x7fcdb018f358&gt;), ('(4, 5, 6){}', &lt;__main__.KeywordTest object at 0x7fcdb018f908&gt;)])
</pre>
<p>Now we have a cache that keeps order of when it's values were created.</p>
<p>Something curious about this setup is that instances of the memoized
class <em>can't</em> access the cache.</p>
<pre class="code ipython3 literal-block">
<span class="n">f</span><span class="o">.</span><span class="n">cache</span>
</pre>
<pre class="literal-block">
---------------------------------------------------------------------------

AttributeError                            Traceback (most recent call last)

&lt;ipython-input-18-e5f688beb613&gt; in &lt;module&gt;()
----&gt; 1 f.cache


AttributeError: 'Frob' object has no attribute 'cache'
</pre>
<p>Which is very handy considering we probably don't want instances
accidentally mucking about and overwriting the cache.</p>
</div>
</div>
<div class="section" id="currying-and-memoization-metaclass">
<h2>Currying AND Memoization Metaclass</h2>
<p>What if we wanted currying and memoization on the same class? Seems
impossible since Python imposes a restriction of one metaclass per
inheritance chain. However, since metaclasses are just regular classes,
we can compose them together to form much more complex metaclasses.</p>
<p>Notice how I was using <tt class="docutils literal">super</tt> to call to things like <tt class="docutils literal">__new__</tt>,
<tt class="docutils literal">__init__</tt> and <tt class="docutils literal">__call__</tt> above rather than explicitly saying,
<tt class="docutils literal">type.__new__</tt>? This was to allow for this exact thing. With that
already in place, all we need to do to create a curried and memoized
class is to just place those two metaclasses together.</p>
<p>However, there is one thing that needs to be noted: order matters. See
Raymond Hettinger's PyCon 2015 talk <a class="reference external" href="https://www.youtube.com/watch?v=EiOglTERPEo">Super Considered
Super</a> to see why. If we
want to curry <em>then</em> memoize, we simply do this:</p>
<pre class="code ipython3 literal-block">
<span class="k">class</span> <span class="nc">CurriedMemoized</span><span class="p">(</span><span class="n">Curryable</span><span class="p">,</span> <span class="n">Memoized</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">CMTester</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">CurriedMemoized</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">pass</span>
</pre>
<p>So far so good. Let's test it out...</p>
<pre class="code ipython3 literal-block">
<span class="n">CMTester</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">CMTester</span><span class="o">.</span><span class="n">cache</span><span class="p">)</span>
</pre>
<pre class="literal-block">
{((1, 2, 3), None): &lt;__main__.CMTester object at 0x7fcdb011c438&gt;}
</pre>
<p>What about taking advantage of Memoized keyword arguments?</p>
<pre class="code ipython3 literal-block">
<span class="k">class</span> <span class="nc">CMKeywordTest</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">CurriedMemoized</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">make_string_key</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="n">OrderedDict</span><span class="p">()):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">pass</span>

<span class="n">CMKeywordTest</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">CMKeywordTest</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">CMKeywordTest</span><span class="o">.</span><span class="n">cache</span><span class="p">)</span>
</pre>
<pre class="literal-block">
OrderedDict([('(1, 2, 3){}', &lt;__main__.CMKeywordTest object at 0x7fcdb018fdd8&gt;), ('(4, 5, 6){}', &lt;__main__.CMKeywordTest object at 0x7fcdb018fd68&gt;)])
</pre>
<p>Now, if we had swapped Memoized and Curryable around in the MRO, we'd
get compeletly different behavior:</p>
<pre class="code ipython3 literal-block">
<span class="k">class</span> <span class="nc">MemoizedCurry</span><span class="p">(</span><span class="n">Memoized</span><span class="p">,</span> <span class="n">Curryable</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">MCTest</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">MemoizedCurry</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">frob</span><span class="p">):</span>
        <span class="k">pass</span>

<span class="n">m</span> <span class="o">=</span> <span class="n">MCTest</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">'default frob'</span><span class="p">)</span>
<span class="n">m</span><span class="p">(</span><span class="n">frob</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">MCTest</span><span class="o">.</span><span class="n">cache</span><span class="p">)</span>
</pre>
<pre class="literal-block">
{(None, frozenset({('name', 'default frob')})): &lt;function MCTest at 0x7fcdb01836a8&gt;}
</pre>
<p>In this case, we're memoizing just what's partially applied rather than
the actual instance. In this particular case, it's probably undesired
behavior, but with other metaclasses, this might be the intended order
of operations.</p>
</div>
<div class="section" id="parting-thoughts">
<h2>Parting Thoughts</h2>
<p>Hopefully this has been a nice introduction to metaclasses and has shown
some pratical applications of them rather than some silly examples. If
you're still curious about writing your own metaclasses or learning more
about them, here's some resources I recommend:</p>
<ul class="simple">
<li><a class="reference external" href="http://pyvideo.org/video/3508/descriptors-and-metaclasses">Mike Mueller - Descriptors and
Metaclasses</a></li>
<li><a class="reference external" href="http://pyvideo.org/video/1716/python-3-metaprogramming">Dave Beazley - Python 3
Metaprogramming</a></li>
<li><a class="reference external" href="http://pyvideo.org/video/2445/intro-to-metaclasses">Craig de Stigter - Intro to
Metaclasses</a></li>
</ul>
</div>

            <aside>
            <nav>
            <ul class="articles_timeline">
 
                <li class="previous_article">« <a href="http://justanr.github.io/quotly-building-a-simple-json-api-with-flask-marshmallow-and-sqlalchemy" title="Previous: Quotly: Building a simple JSON API with Flask, Marshmallow and SQLAlchemy">Quotly: Building a simple JSON API with Flask, Marshmallow and SQLAlchemy</a></li>
 
                <li class="next_article"><a href="http://justanr.github.io/demon-hunter-demon-hunter-review" title="Next: Demon Hunter - Demon Hunter Review">Demon Hunter - Demon Hunter Review</a> »</li>
            </ul>
            </nav>
            </aside>
<section>
<hr/>
<p id="comment-message">I spilled my brains, spill some of yours. </p>
<div class="accordion" id="accordion2">
    <div class="accordion-group">
        <div class="accordion-heading">
            <a class="accordion-toggle disqus-comment-count" data-toggle="collapse" data-parent="#accordion2" 
                href="http://justanr.github.io/currying-and-memoizing-metaclasses/#disqus_thread">
                Comments
            </a>
        </div>
        <div id="disqus_thread" class="accordion-body collapse">
            <div class="accordion-inner">
                <div class="comments">
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'ballinoctobear';
        var disqus_identifier = 'http://justanr.github.io/currying-and-memoizing-metaclasses';
    var disqus_url = 'http://justanr.github.io/currying-and-memoizing-metaclasses';

    (function() {
         var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
         dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
         (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
     })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>                </div>
            </div>
        </div>
    </div>
</div>
</section>
        </div>
        <section>
        <div class="span2" style="float:right;font-size:0.9em;">
 
            <h4>Published</h4>
            <time pubdate="pubdate" datetime="2015-05-13T00:00:00-04:00">May 13, 2015</time>
            <h4>Category</h4>
            <a class="category-link" href="/categories.html#tutorials-ref">tutorials</a> 
            <h4>Tags</h4>
            <ul class="list-of-tags tags-in-article"> 
                <li><a href="/tags.html#metaprogramming-ref">metaprogramming
                    <span>1</span>
</a></li>
                <li><a href="/tags.html#python3-ref">python3
                    <span>1</span>
</a></li>
            </ul>

        </div>
        </section>
    </div>
    </article>
                </div>
                <div class="span1"></div>
            </div>
        </div>
    </div>
<footer>
<div id="footer">
    <ul class="footer-content">
        <li class="elegant-license">Shared under the Creative Commons for content and MIT for code</li>
        <li class="elegant-power">Powered by <a href="http://getpelican.com/" title="Pelican Home Page">Pelican</a>. Theme: <a href="http://oncrashreboot.com/pelican-elegant" title="Theme Elegant Home Page">Elegant</a> by <a href="http://oncrashreboot.com" title="Talha Mansoor Home Page">Talha Mansoor</a></li>
    </ul>
</div>
</footer>            <script src="http://code.jquery.com/jquery.min.js"></script>
        <script src="//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.1/js/bootstrap.min.js"></script>
        <script>
            function validateForm(query)
            {
                return (query.length > 0);
            }
        </script>

<script type="text/javascript">
    var disqus_shortname = 'ballinoctobear';

    (function () {
        var s = document.createElement('script'); s.async = true;
        s.type = 'text/javascript';
        s.src = '//' + disqus_shortname + '.disqus.com/count.js';
        (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
    }());
    </script>
    </body>
</html>