<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>from alec.thoughts import * - libraries</title><link href="http://justanr.github.io/" rel="alternate"></link><link href="http://justanr.github.io/feeds/libraries.atom.xml" rel="self"></link><id>http://justanr.github.io/</id><updated>2015-04-06T00:00:00-04:00</updated><entry><title>Fizzbuzz With Pynads!</title><link href="http://justanr.github.io/fizzbuzz-with-pynads" rel="alternate"></link><published>2015-04-06T00:00:00-04:00</published><updated>2015-04-06T00:00:00-04:00</updated><author><name>Alec Nikolas Reiter</name></author><id>tag:justanr.github.io,2015-04-06:/fizzbuzz-with-pynads</id><summary type="html">&lt;pre class="code ipython3 literal-block"&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;pynads&lt;/span&gt; &lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="n"&gt;Writer&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;pynads.funcs&lt;/span&gt; &lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="n"&gt;multibind&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;itertools&lt;/span&gt; &lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="n"&gt;repeat&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;functools&lt;/span&gt; &lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="n"&gt;partial&lt;/span&gt;

&lt;span class="n"&gt;pairs&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'fizz'&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'buzz'&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;fizzer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;pairs&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;fizzed&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;''&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;join&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;buzz&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;fizz&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;buzz&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;pairs&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;fizz&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="ow"&gt;or&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;Writer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;fizzed&lt;/span&gt;&lt;span class="p"&gt;})&lt;/span&gt;

&lt;span class="n"&gt;res&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;multibind&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Writer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1 â€¦&lt;/span&gt;&lt;/pre&gt;</summary><content type="html">&lt;pre class="code ipython3 literal-block"&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;pynads&lt;/span&gt; &lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="n"&gt;Writer&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;pynads.funcs&lt;/span&gt; &lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="n"&gt;multibind&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;itertools&lt;/span&gt; &lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="n"&gt;repeat&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;functools&lt;/span&gt; &lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="n"&gt;partial&lt;/span&gt;

&lt;span class="n"&gt;pairs&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'fizz'&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'buzz'&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;fizzer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;pairs&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;fizzed&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;''&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;join&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;buzz&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;fizz&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;buzz&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;pairs&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;fizz&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="ow"&gt;or&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;Writer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;fizzed&lt;/span&gt;&lt;span class="p"&gt;})&lt;/span&gt;

&lt;span class="n"&gt;res&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;multibind&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Writer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{}),&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;repeat&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;partial&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fizzer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;pairs&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;pairs&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="mi"&gt;15&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;
&lt;pre class="literal-block"&gt;
Writer(16, {1: 1, 2: 2, 3: 'buzz', 4: 4, 5: 'fizz', 6: 'buzz', 7: 7, 8: 8, 9: 'buzz', 10: 'fizz', 11: 11, 12: 'buzz', 13: 13, 14: 14, 15: 'fizzbuzz'})
&lt;/pre&gt;
&lt;p&gt;Truly an 11x Developer solution to the [STRIKEOUT:world's] universe's
premier code interview question!&lt;/p&gt;
&lt;div class="section" id="what-is-pynads"&gt;
&lt;h2&gt;What is &amp;quot;pynads&amp;quot;&lt;/h2&gt;
&lt;p&gt;All joking aside, I've been hacking together a collection of
Haskell-esque tools for Python over the last few weeks. It started as a
&amp;quot;Well, I'll learn Haskell better this way.&amp;quot; and has become...well,
honestly a tool for me learning Haskell still.&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="https://github.com/justanr/pynads"&gt;Check it out&lt;/a&gt;, I think it's
nifty.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="a-quick-tour-of-pynads"&gt;
&lt;h2&gt;A Quick Tour of Pynads&lt;/h2&gt;
&lt;p&gt;pynads strives to be a pythonic form of Haskell. Which is buzzword for I
did some stuff. There's:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Functors&lt;/li&gt;
&lt;li&gt;Applicatives&lt;/li&gt;
&lt;li&gt;Monads&lt;/li&gt;
&lt;li&gt;Monoids&lt;/li&gt;
&lt;li&gt;Helpers&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;All of the base classes are implemented as Abstract Base Classes which
makes inheritance easy. Well, that's a lie, the root object of pynads is
a concrete class that just serves as an endpoint for &lt;tt class="docutils literal"&gt;__new__&lt;/tt&gt; and
&lt;tt class="docutils literal"&gt;__init__&lt;/tt&gt;.&lt;/p&gt;
&lt;div class="section" id="container"&gt;
&lt;h3&gt;Container&lt;/h3&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;pynads.Container&lt;/tt&gt; is the root object of every &lt;tt class="docutils literal"&gt;pynads&lt;/tt&gt; class. It
serves as a final endpoint for &lt;tt class="docutils literal"&gt;__new__&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;__init__&lt;/tt&gt; as well as
providing a consistent name for accessing the values held by objects in
&lt;tt class="docutils literal"&gt;pynads&lt;/tt&gt;. Some would say that it's a silly idea, but it works! Every
class in &lt;tt class="docutils literal"&gt;pynads&lt;/tt&gt; is also slotted for memory reasons since it's built
around the idea of not manipulating a container but creating a new one.&lt;/p&gt;
&lt;p&gt;The only important thing to know about Container is that it defines
&lt;tt class="docutils literal"&gt;v&lt;/tt&gt; as a property which actually delagates to the &lt;tt class="docutils literal"&gt;_get_val&lt;/tt&gt; method.
Meaning that's all that needs to be overriden to get multiple values out
of a container.&lt;/p&gt;
&lt;p&gt;For most subclasses of Container, the provided &lt;tt class="docutils literal"&gt;__init__&lt;/tt&gt; is fine, but
it's a-ok to override it as well as the only setup that happens is
setting a single attribute &lt;tt class="docutils literal"&gt;_v&lt;/tt&gt;.&lt;/p&gt;
&lt;pre class="code ipython3 literal-block"&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;pynads&lt;/span&gt; &lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="n"&gt;Container&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Person&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Container&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="vm"&gt;__slots__&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'name'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'age'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;age&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;age&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;age&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;_get_val&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s1"&gt;'name'&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'age'&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;age&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__repr__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Person(name=&lt;/span&gt;&lt;span class="si"&gt;{!s}&lt;/span&gt;&lt;span class="s2"&gt;, age=&lt;/span&gt;&lt;span class="si"&gt;{!s}&lt;/span&gt;&lt;span class="s2"&gt;)&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;age&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Person&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Alec&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;age&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;26&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;
&lt;pre class="literal-block"&gt;
{'age': 26, 'name': 'Alec'}
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="functors"&gt;
&lt;h3&gt;Functors&lt;/h3&gt;
&lt;p&gt;Functors are data types that can be mapped over with the &lt;tt class="docutils literal"&gt;fmap&lt;/tt&gt;
method. But calling methods isn't very Haskell like, so there's an
operator that does the same thing: &lt;tt class="docutils literal"&gt;%&lt;/tt&gt;.&lt;/p&gt;
&lt;pre class="code ipython3 literal-block"&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;pynads&lt;/span&gt; &lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="n"&gt;Functor&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;FmapPerson&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Person&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Functor&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="vm"&gt;__slots__&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;fmap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="vm"&gt;__class__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;age&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;upper&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;FmapPerson&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Alec&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;age&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;26&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;
&lt;pre class="literal-block"&gt;
Person(name=ALEC, age=26)
&lt;/pre&gt;
&lt;p&gt;Of course, you &lt;em&gt;could&lt;/em&gt; just use &lt;tt class="docutils literal"&gt;FmapPerson.fmap&lt;/tt&gt; but that's not very
Haskellic. &lt;tt class="docutils literal"&gt;pynads&lt;/tt&gt; also exports a &lt;tt class="docutils literal"&gt;funcs&lt;/tt&gt; name space that contains
functional shortcuts to some of these (though &lt;tt class="docutils literal"&gt;f % functor&lt;/tt&gt; doesn't
get much shorter). In this case, there's also:&lt;/p&gt;
&lt;pre class="code ipython3 literal-block"&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;pynads&lt;/span&gt; &lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="n"&gt;funcs&lt;/span&gt;

&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;funcs&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;fmap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;upper&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;FmapPerson&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Alec&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;age&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;26&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;
&lt;pre class="literal-block"&gt;
Person(name=ALEC, age=26)
&lt;/pre&gt;
&lt;p&gt;Every class in the &lt;tt class="docutils literal"&gt;pynads.concrete&lt;/tt&gt; namespace is a functor except for
&lt;tt class="docutils literal"&gt;Mempty&lt;/tt&gt; (we'll get there!).&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="applicatives"&gt;
&lt;h3&gt;Applicatives&lt;/h3&gt;
&lt;p&gt;Applicative Functors are functors that hold functions and can then be
applied to other Applicatives/Functors. Every class (except for
&lt;tt class="docutils literal"&gt;Mempty&lt;/tt&gt;) in &lt;tt class="docutils literal"&gt;pynads.concrete&lt;/tt&gt; is also an Applicative!&lt;/p&gt;
&lt;pre class="code ipython3 literal-block"&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;pynads&lt;/span&gt; &lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="n"&gt;Just&lt;/span&gt;

&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Just&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;Just&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;
&lt;pre class="literal-block"&gt;
Just 4
&lt;/pre&gt;
&lt;p&gt;Yeah, like Haskell there's an infix operator. Except of &lt;tt class="docutils literal"&gt;&amp;lt;*&amp;gt;&lt;/tt&gt; I just
dropped the angle brackets because Python doesn't let you define custom
operators (easily). It also combines nicely with &lt;tt class="docutils literal"&gt;%&lt;/tt&gt; because they have
the same precedence level!&lt;/p&gt;
&lt;pre class="code ipython3 literal-block"&gt;
&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;Just&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;Just&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;
&lt;pre class="literal-block"&gt;
Just 10
&lt;/pre&gt;
&lt;p&gt;BOOM! Mind blown! Whaaaaaat. Applicative uses the abstract method
&lt;tt class="docutils literal"&gt;apply&lt;/tt&gt; to determine how &lt;tt class="docutils literal"&gt;*&lt;/tt&gt; operates. Just inherit from
Applicative, define &lt;tt class="docutils literal"&gt;fmap&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;apply&lt;/tt&gt; and boom, you're on your way.
Well, you also need the &lt;tt class="docutils literal"&gt;unit&lt;/tt&gt; method -- which is a class method for
all &lt;tt class="docutils literal"&gt;pynad&lt;/tt&gt; types, but that's not a requirement -- which knows how to
put a value in a minimal context.&lt;/p&gt;
&lt;p&gt;But wait, what if you have a curried function and you stuffed it into a
Just and now you don't want to write out
&lt;tt class="docutils literal"&gt;just_f * just_v1 * just_v2 ...&lt;/tt&gt;. Sure, you could think &amp;quot;Well, what if
I used &lt;tt class="docutils literal"&gt;reduce(operator.mul, *justs)&lt;/tt&gt;&amp;quot; But I thought of that already.&lt;/p&gt;
&lt;pre class="code ipython3 literal-block"&gt;
&lt;span class="n"&gt;add_three_together&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="n"&gt;z&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;z&lt;/span&gt;

&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;funcs&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;multiapply&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Just&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;add_three_together&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Just&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)]))&lt;/span&gt;
&lt;/pre&gt;
&lt;pre class="literal-block"&gt;
Just 6
&lt;/pre&gt;
&lt;p&gt;If you're mind isn't blown yet, it's because I haven't revealed...&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="mooooooooonaaaaaaaads"&gt;
&lt;h3&gt;MOOOOOOOOONAAAAAAAADS!!!!!&lt;/h3&gt;
&lt;p&gt;Monads get a bad rap because they get all sorts of overblown
explainations. You want to know a what a monad is? It's another way to
compute things. It's a glorified container with a special method. You
have a value in a monad, a function that takes a regular value and
returns a monad and you bind them together. That's it. Literally all
there is to it.&lt;/p&gt;
&lt;pre class="code ipython3 literal-block"&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;pynads&lt;/span&gt; &lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="n"&gt;Nothing&lt;/span&gt;

&lt;span class="n"&gt;inc_if_odd_else_nothing&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Just&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="n"&gt;Nothing&lt;/span&gt;

&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Just&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;inc_if_odd_else_nothing&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;
&lt;pre class="literal-block"&gt;
Just 3
&lt;/pre&gt;
&lt;p&gt;The Maybe monad (which consists of the Just and Nothing data types) is
basically a glorified if expression. That's it! The bind operation will
detect if you have a failure in your computation and short circuit it.
It's essentially an abstraction over this:&lt;/p&gt;
&lt;pre class="code ipython3 literal-block"&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;safe_func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="kc"&gt;None&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="kc"&gt;None&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;

&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;safe_func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;safe_func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kc"&gt;None&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;
&lt;pre class="literal-block"&gt;
2 None
&lt;/pre&gt;
&lt;p&gt;Notice how that didn't cause a nasty AttributeError, because None
doesn't have attributes? That's all Maybe lets you do (this behavior is
mimicked in its fmap and apply: &lt;tt class="docutils literal"&gt;fmap(f, Nothing)&lt;/tt&gt; and
&lt;tt class="docutils literal"&gt;apply(ap_f, Nothing)&lt;/tt&gt; both return you a Nothing). Nothing is
extraspecialsauce because it's a singleton. It's basically a monadic
None. Actually, it &lt;em&gt;is&lt;/em&gt; a monadic None because it represents...well,
Nothing.&lt;/p&gt;
&lt;p&gt;If you've got more binds than editor columns, then there's something for
you as well!&lt;/p&gt;
&lt;pre class="code ipython3 literal-block"&gt;
&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;multibind&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Just&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;repeat&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Just&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;
&lt;pre class="literal-block"&gt;
Just 6
&lt;/pre&gt;
&lt;p&gt;Before you start thinking, &amp;quot;Well, monads are just glorified if
expressions&amp;quot; becuase that's missing the point, Monads are the
abstraction abstraction. They represent a way to compute something by
abstracting away &lt;em&gt;how&lt;/em&gt; it's computated.&lt;/p&gt;
&lt;p&gt;There's the Writer monad above which is a value in a monadic context but
it also keeps some extra side-output as well. Instead of us trying to
track this extra information ourselves, Writer says, &amp;quot;Hey, I'll handle
it for you!&amp;quot; It just wants a function that accepts a value and returns a
Writer. But here's the really cool thing, I &lt;em&gt;didn't&lt;/em&gt; have to use a
dictionary. It could have a list, or a string or an integer, or a custom
class! I hear, &amp;quot;But how!&amp;quot; Through the power of...&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="monoids"&gt;
&lt;h3&gt;Monoids!&lt;/h3&gt;
&lt;p&gt;So monoids are pretty cool. They're a set of something, a &amp;quot;zero&amp;quot; and a
binary operator that's transative. Lots of things form monoids. Numbers
are monoids! There's &lt;em&gt;two&lt;/em&gt; ways to make numbers monoids: with &lt;tt class="docutils literal"&gt;0&lt;/tt&gt; and
&lt;tt class="docutils literal"&gt;+&lt;/tt&gt;, with &lt;tt class="docutils literal"&gt;1&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;*&lt;/tt&gt;. However, &lt;tt class="docutils literal"&gt;pynads&lt;/tt&gt; is lazy and only
defines the first...sorry, hard choices were made.&lt;/p&gt;
&lt;p&gt;Wait, &amp;quot;a zero value&amp;quot; but &lt;tt class="docutils literal"&gt;1 != 0&lt;/tt&gt;. That's missing the point, a zero
value is a value that doesn't change the input when combined with the
binary operator. &lt;tt class="docutils literal"&gt;x * 1 == x&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;But Python's &amp;quot;primitive&amp;quot; types all form monads!&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;list&lt;/tt&gt; is a monoid. That's the zero value right there and it's
binary operator would be &lt;tt class="docutils literal"&gt;list.extend&lt;/tt&gt; if it was actually a binop.&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;dict&lt;/tt&gt; is a monoid with &lt;tt class="docutils literal"&gt;{}&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;dict.update&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;bool&lt;/tt&gt; is a monoid with &lt;tt class="docutils literal"&gt;False&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;|&lt;/tt&gt;\&lt;tt class="docutils literal"&gt;or&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;set&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;frozenset&lt;/tt&gt; are also monoids with their empty instances
and &lt;tt class="docutils literal"&gt;|&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;str&lt;/tt&gt; is a monoid with &lt;tt class="docutils literal"&gt;''&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;+&lt;/tt&gt; (boooo using &lt;tt class="docutils literal"&gt;+&lt;/tt&gt; to
combine strings! but whatever)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Tuple, Complex and Float are also monoids in exactly the ways you
expect. There's a catch though: When combining tuples, you actually get
a list back. I'll probably rectify this at a later point, but it's just
something to live with right now.&lt;/p&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;pynads&lt;/tt&gt; also defines [STRIKEOUT:two] three monoids of its own:
&lt;tt class="docutils literal"&gt;List&lt;/tt&gt; (the monadic form of &lt;tt class="docutils literal"&gt;tuple&lt;/tt&gt;), &lt;tt class="docutils literal"&gt;Map&lt;/tt&gt; (the applicative form
of &lt;tt class="docutils literal"&gt;dict&lt;/tt&gt;) and &lt;tt class="docutils literal"&gt;Mempty&lt;/tt&gt; (which we're getting to!).&lt;/p&gt;
&lt;p&gt;Making your own monoid is easy, and you've probably done it before (just
not in this fashion). Just inherit from &lt;tt class="docutils literal"&gt;pynads.Monoid&lt;/tt&gt; create a
&lt;tt class="docutils literal"&gt;mempty&lt;/tt&gt; attribute (it won't let you without it through &lt;tt class="docutils literal"&gt;__new__&lt;/tt&gt;
hackery) and the &lt;tt class="docutils literal"&gt;mappend&lt;/tt&gt; method for combining two instances of your
monoid. Let's assume we want a &lt;em&gt;real&lt;/em&gt; tuple Monoid. We'd do it like
this:&lt;/p&gt;
&lt;pre class="code ipython3 literal-block"&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;pynads&lt;/span&gt; &lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="n"&gt;Monoid&lt;/span&gt;

&lt;span class="c1"&gt;# also inherits from Container&lt;/span&gt;
&lt;span class="c1"&gt;# so we get all the Container goodness for free&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;MTuple&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Monoid&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;mempty&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;vs&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="nb"&gt;super&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;MTuple&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;mappend&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;other&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="c1"&gt;# type checking optional&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="nb"&gt;isinstance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;other&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;MTuple&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
            &lt;span class="k"&gt;raise&lt;/span&gt; &lt;span class="ne"&gt;TypeError&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Can only mappend MTuple with MTuple&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;MTuple&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;other&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__repr__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;MTuple&lt;/span&gt;&lt;span class="si"&gt;{!r}&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;
&lt;pre class="code ipython3 literal-block"&gt;
&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;MTuple&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;MTuple&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;
&lt;pre class="literal-block"&gt;
MTuple(4, 5, 6, 7)
&lt;/pre&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;pynads.Monoid&lt;/tt&gt; overrides &lt;tt class="docutils literal"&gt;+&lt;/tt&gt; to be a shortcut to &lt;tt class="docutils literal"&gt;mappend&lt;/tt&gt;.
That's all well and good, but &lt;em&gt;why&lt;/em&gt; other than have a unified way of
combining values?! Because we get a way to reduce a list of monoids into
a single value for free!&lt;/p&gt;
&lt;pre class="code ipython3 literal-block"&gt;
&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;MTuple&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;mconcat&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;MTuple&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;MTuple&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;MTuple&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;
&lt;pre class="literal-block"&gt;
MTuple(1, 2, 3)
&lt;/pre&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;Monoid.mconcat&lt;/tt&gt; actually delegates to the &lt;tt class="docutils literal"&gt;mappend&lt;/tt&gt; method and
essentially looks like &lt;tt class="docutils literal"&gt;reduce(cls.mappend, monoids)&lt;/tt&gt;. That's it.
That's all there is. But you can define your own &lt;tt class="docutils literal"&gt;mconcat&lt;/tt&gt; to get
performace bonuses if you need to.&lt;/p&gt;
&lt;pre class="code ipython3 literal-block"&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;itertools&lt;/span&gt; &lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="n"&gt;chain&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;CMTuple&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;MTuple&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__iter__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;iter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="nd"&gt;&amp;#64;classmethod&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;mconcat&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;cls&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;MTuples&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;CMTuple&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;chain&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;from_iterable&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;MTuples&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;
&lt;pre class="code ipython3 literal-block"&gt;
&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CMTuple&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;mconcat&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CMTuple&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;CMTuple&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;CMTuple&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;
&lt;pre class="literal-block"&gt;
MTuple(1, 2, 3)
&lt;/pre&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;pynads.List&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;pynads.Map&lt;/tt&gt; take advantage of this to create only
one intermediate object rather than a bunch. &lt;tt class="docutils literal"&gt;pynads&lt;/tt&gt; will also let
you treat the builtin types as monoids as well through
&lt;tt class="docutils literal"&gt;pynads.funcs.monoid&lt;/tt&gt; namespace which has four functions we're
interested in: &lt;tt class="docutils literal"&gt;mempty&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;mappend&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;mconcat&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;is_monoid&lt;/tt&gt;.
&lt;tt class="docutils literal"&gt;mempty&lt;/tt&gt; returns the &amp;quot;zero&amp;quot; value for a type, &lt;tt class="docutils literal"&gt;mappend&lt;/tt&gt; knows how to
combine types, &lt;tt class="docutils literal"&gt;mconcat&lt;/tt&gt; knows how to combine an iter of types into a
single one and &lt;tt class="docutils literal"&gt;is_monoid&lt;/tt&gt; knows if something is monoidal or not
(generally, it doesn't declare &lt;tt class="docutils literal"&gt;decimal.Decimal&lt;/tt&gt; to be a monoid but
this is because I didn't want to add a special case -- special cases
beget special cases).&lt;/p&gt;
&lt;p&gt;This is done through introspection of types and abstract base classes
(to make the type introspection [STRIKEOUT:more acceptable] less
painful).&lt;/p&gt;
&lt;pre class="code ipython3 literal-block"&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;pynads.funcs&lt;/span&gt; &lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="n"&gt;monoid&lt;/span&gt;

&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;monoid&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;mempty&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;list&lt;/span&gt;&lt;span class="p"&gt;()))&lt;/span&gt;
&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;monoid&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;mappend&lt;/span&gt;&lt;span class="p"&gt;({&lt;/span&gt;&lt;span class="s1"&gt;'a'&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s1"&gt;'b'&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;}))&lt;/span&gt;
&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;monoid&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;mconcat&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;hello&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot; &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;world&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;monoid&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;is_monoid&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;set&lt;/span&gt;&lt;span class="p"&gt;()))&lt;/span&gt;
&lt;/pre&gt;
&lt;pre class="literal-block"&gt;
[]
{'a': 10, 'b': 7}
hello world
True
&lt;/pre&gt;
&lt;p&gt;The monoid namespace is just a nice interface to the nasty plumbing that
lives in &lt;tt class="docutils literal"&gt;pynads.utils.monoidal&lt;/tt&gt;. It's pretty gross and actually
probably pretty fragile, but it works! IT WORKS!!!&lt;/p&gt;
&lt;div class="section" id="mempty"&gt;
&lt;h4&gt;Mempty&lt;/h4&gt;
&lt;p&gt;So here's the thing that lets &lt;tt class="docutils literal"&gt;Writer&lt;/tt&gt; do its little trick by accept
any monoid as a potential log. I can't know ahead of time what you're
going to use to keep track of stuff with &lt;tt class="docutils literal"&gt;Writer&lt;/tt&gt; -- I've drank plenty
of spice water, but I've yet to develop prescient abilities. And rather
than making a bunch of subclasses specialized to handle a dictionary and
a list and a string and a blah blah blah and forcing you to make your
own for &lt;tt class="docutils literal"&gt;WriterLogWithMyFirstMonoid&lt;/tt&gt; I decided to create a mempty
monoid -- &lt;tt class="docutils literal"&gt;Mempty&lt;/tt&gt;. It's not an original idea. Really, it's kind of a
dumb object.&lt;/p&gt;
&lt;p&gt;It's a singleton, so that's a strike against it (two singletons in my
library, my god!). It doesn't actually &lt;em&gt;do&lt;/em&gt; anything. It just sits
around, taking up space until a real monoid comes along and scares it
off. It's mempty value is actually itself! It's mappend just returns
whatever its mappended with. And it's mconcat filters out any Mempty
values before trying to mconcat the remaining values (you get a Mempty
if mconcat an iter of Mempties). There's even an &lt;tt class="docutils literal"&gt;__iter__&lt;/tt&gt; method
that yields from an empty tuple! What's going on!&lt;/p&gt;
&lt;p&gt;In Haskell, &lt;tt class="docutils literal"&gt;mempty&lt;/tt&gt; can be used a place holder and Haskell knows to
do the right thing already. However, we have to teach Python how to use
a placeholder and silently step it out of the way when a real value
comes along. I suspect that this is similar, maybe, to how Haskell
handles it, but I've not dug at all.&lt;/p&gt;
&lt;pre class="code ipython3 literal-block"&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;pynads&lt;/span&gt; &lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="n"&gt;Mempty&lt;/span&gt;

&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;monoid&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;mempty&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Mempty&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Mempty&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;monoid&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;mconcat&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Mempty&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt; &lt;span class="n"&gt;Mempty&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;
&lt;pre class="literal-block"&gt;
Mempty
4
{4, 5}
&lt;/pre&gt;
&lt;p&gt;So Writer's little trick of allowing any Monoid be the log is really
just, &amp;quot;I have this dumb thing that pretends to be a Monoid as a default
log.&amp;quot;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="helpers"&gt;
&lt;h3&gt;Helpers&lt;/h3&gt;
&lt;p&gt;I won't explore this section indepth because &lt;tt class="docutils literal"&gt;pynads.funcs&lt;/tt&gt; has a
whole host of helpers, with more being added as needed. There's helpers
for making constants, composing functions, an identity function (as in
&lt;tt class="docutils literal"&gt;lambda x: x&lt;/tt&gt; not &lt;tt class="docutils literal"&gt;id(x)&lt;/tt&gt;), turning values into Monads. There's also
&lt;tt class="docutils literal"&gt;pynads.utils&lt;/tt&gt; if you need to plumb some of the internal workings like
compatibility (did I mention all the tests pass 3.4 and 2.7?!) or how
monoids are determined on things that aren't explicitly monoids.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="that-s-it"&gt;
&lt;h3&gt;That's it!&lt;/h3&gt;
&lt;p&gt;Well, not really. There's about five other monads implemented that I
didn't cover (like Reader, which was a pain but also a lot of fun to
implement). There's more coming as well. Not just monads, but other
things. A proof of concept for do notation via abusing coroutines exists
in the repo (lifted from a blog called &lt;a class="reference external" href="http://www.valuedlessons.com/2008/01/monads-in-python-with-nice-syntax.html"&gt;Valued
Lessons&lt;/a&gt;
which served as partial inspiration for this project). And maybe Monad
Transformers if I work the gumption up for it (probably yes). And who
knows what else.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</content><category term="python"></category><category term="pynads"></category><category term="haskell"></category></entry></feed>